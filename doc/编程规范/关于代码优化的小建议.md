 1. 需要map 的主键和取值时，迭代 entrySet()
> 当循环中只需要map 的主键时，迭代keySet 是正确的，但是，当需要主键和取值时，迭代entrySet 才是更高效的做法。 比 先迭代keySet 后再去get 取值性能更高

2. 应该使用Collection.isEmpty （） 检查空
> 使用Collection.size 来检查空逻辑上是没有问题，但是使用Collection.isEmpty 使得代码更易读，并且可以获得更好的性能，任何collection.isEmpty 实现的时间复杂度都是 O(1) ,但是 某些collection.size 的时间复杂度可能是 O (n) 如果还需要检查null ，可以使用CollectionUtils.isEmpty（collection）

3. 集合初始化尽量指定大小
> 集合的扩容是使用动态扩展，一般是倍数的扩展，而每一次扩容都是一次数组的拷贝，如果数据量大，拷贝就会非常消耗资源。 集合扩容的时间复杂度很有可能是O（n），所以尽量指定可预知的集合大小，能减少集合的扩容次数 （在大数据量下，是否指定容量会使性能相差5 倍以上）
4. 如果需要频繁调用collection.contains 方法，使用Set
> ava 集合中， List  的contains 方法普遍时间复杂度为 O （n） ，如果再代码中需要频繁调用contains 方法查找数据，可以先将list 转换为 hashSet 实现，将O（n） 的时间复杂度降为 O (1)
5. 建议使用try-with-resources
6. 工具类应该屏蔽构造函数
7. 返回空数组和空集合而不是null 
> 返回null ，需要调用方强制检查null ，否则就会抛出空指针异常，返回空数组或空集合，有效地避免了调用方因为未检测null 而抛出空指针异常
8. 优先使用常量或确定值来调用equals 方法
对象的equals 方法容易抛出空指针异常，应使用常量或确定有值的对象来调用equals 方法，当然，使用java.util.Objeccts.equasls  方法是最佳实践
9. 小心 String.split(String regex)
> 字符串string 的split 方法，传入的分割字符串是正则表达式，部分关键字（如 .[] () \| ）需要转义
"a.ab.abc".split("\\."); // 结果为["a", "ab", "abc"]
"a|ab|abc".split("\\|"); // 结果为["a", "ab", "abc"]

10. 使用卫语句
> 卫语句，就是把复杂的条件表达式拆分成多个条件表达式， 比如多个if-elseif-else 嵌套，可以拆分成多个if 使用return 提前返回
11. 避免使用Map Json 这些复杂对象作为参数和结果
12. 将可变的地方封装成函数、
> 把代码的逻辑抽象出来封装成为一个函数，以应对将来可能的变化。以后代码逻辑有变更的时候，单独修改和测试这个函数即可
13. 编写能测试的函数
> 把函数写小一点 ，力求每一个函数都可以单独测试。这样会节约大量的时间，尤其是代码频繁改动的时候。要有单独测试每一个函数的习惯。不要一上来就测试整个功能，应该一行一行代码、一个一个函数测试，有了这个习惯，自然就会写出能测试的小函数。
14. 若非必要，不要克隆对象
> 一般情况下，new 生成的对象，比 clone 生成的性能方面要好很多
15. 三目运算符的类型必须一致
> 三目运算符的操作数的类型必须一致，这样可以减少错误的发生
16. 不要在本类中覆盖静态导入的变量和方法
> 编译器有一个最短路径原则， 如果能够在本类中查找到的变量，常量，方法，就 不会到其他包或父类接口中查找。以确保本类中的属性，方法优先，因此，如果要变更一个被静态导入的方法，最好的方法是在原始类中重构，而不是在本类中覆盖
17. 从性能考虑。 就数组，集合来说，数组是首选 ，若有必要，使用变长数组
18. 数组和集合的最大区别就是数组能容纳基本类型，而集合不行，更重要的一点是，所有的集合底层存储都是数组