32位IA_32 处理器使用==基于对缓存加锁或总线加锁==的方式来实现多处理器之间的原子操作。

首先处理器会自动保证基本的内存原子性。 处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。 处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性

### 使用总线锁保证原子性
如果一个处理器同时对共享变量进行读改写操作，那么共享变量就会被多个处理器同时进行操作，这样进行的操作就不是原子的，操作完之后共享变量的值就会和期望的不一致。原因是在于多个处理器同时从各自的缓存中读取变量，分别进行操作，然后分别写入到系统内存中。如果想保证改写共享变量的操作是原子的，那么就必须保证当一个CPU在读改写共享变量的时候，另外的CPU 不能操作缓存了该共享变量内存地址的缓存。

所谓总线锁，就是使用处理器提供的LOCK#信号，当一个处理器上输出此信号时候，其他处理器的请求就将被阻塞。该处理器可以独占共享内存

### 使用缓存锁保证原子性
由于在同一个时刻，只需要保证某个内存地址的操作是原子性就可以了。而总线锁却将CPU和内存之间的通信锁住，这样会使得锁定期间，其他的处理不能操作其他的内存地址的数据。因此 ，使用总线锁开销比较大。 目前处理器在某些场合下，使用缓存锁来代替总线锁来进行优化

所谓缓存锁定，指的是内存区域如果被缓存在处理器的缓存中，并且在lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不再总线上声明LOCK# 信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。因为缓存一致性会阻止同时修改两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效


