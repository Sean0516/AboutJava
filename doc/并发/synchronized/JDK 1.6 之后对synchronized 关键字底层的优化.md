JDK 1.6 之后对锁的实现引入了大量的优化， 如偏向锁，轻量级锁，自旋锁，适应自旋锁，锁消除，锁粗化 等技术来减少锁操作的开销

锁主要存在四种状态， 依次是无锁状态,偏向锁状态,轻量级锁状态,重量级锁状态.他们会随着竞争的激烈而逐渐升级。 需要注意的是, 锁可以升级但是不能降级。这种策略主要是为了提高获得锁和释放锁的效率

### 偏向锁 

引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 但是不同的是： 轻量级锁在无竞争的情况下使用CAS（比较和交换） 操作去替代使用互斥量。 而偏向锁在无竞争的情况下会吧整个同步都消除掉

偏向锁的意思是：锁会偏向于第一个获得他的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步，但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极可能每次申请锁的线程都是不相同的。 因此这种场合下不应该使用偏向锁。需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁

### 轻量级锁
轻量级锁不上为了代替重量级锁，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量，另外。 轻量级锁的加锁和解锁 ，都用到了CAS  操作。

轻量级锁能够提升程序同步性能的依据是“绝大部分锁，在整个同步周期都是不存在竞争的”这个一个经验数据，如果没有竞争， 轻量级锁使用CAS 操作避免了使用互斥操作的开销，但是如果存在锁竞争，除了互斥量开销外。 还会额外发生CAS 操作， 因此在有锁竞争的情况下， 轻量级锁比传统的重量级锁更慢。 如果锁竞争激烈， 那么轻量级将很快膨胀为重量级锁

### 自旋锁和自适应自旋

轻量级锁失败后，虚拟机为了避免线程真实地在操作层面挂机，还会进行一项称为自旋锁的优化手段

互斥同步对性能最大的影响就是阻塞的实现。因为挂起线程/恢复线程需要转入内核态中完成（用户态转换到内核态会耗费时间）

一般线程持有锁的时间都不是太长，仅仅是为了这点时间就去挂起线程/恢复线程是得不偿失的。 所以，虚拟机开发团队考虑。 能不能让后面来的请求获取锁的线程等待一会而不被挂起， 看持有锁的线程是否会很快释放锁。 为了让一个线程等待，我们只需要让线程执行一个忙循环 。这项技术就叫做自旋

自旋锁不能完全替代阻塞，因为他还是要占用处理器时间。如果锁被占用的时间短 ，那么效果就很好，相反 。自旋等待的时间必须要有限度。 如果自旋超过限定次数仍然没有获得锁，就应该挂起

另外 JDK1.6  引入了自适应的自旋锁 。自适应的自旋锁带来的改进就是，自旋的时间不再固定，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定的

### 锁消除
锁消除指的是 虚拟机即使在编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省无意义的请求锁的时间
### 锁粗化
原则上，我们在编写代码时，总是推荐将同步块的作用范围限制得尽量小，直到共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变得小，如果存储锁竞争，那么等待线程也能尽快拿到锁

大部分情况下，上面的原则都没有问题，但是如果一系列的连续操作都对同一个对象反复加锁和解锁。那么会带来很多不必要的性能消耗

### 锁的优缺点比较


锁 |有点| 缺点 | 适用场景
---|--- |--- |---
偏向锁  | 加锁和加锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 使用于只有一个线程访问同步块的场景
轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快
重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行速度较长


