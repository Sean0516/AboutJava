### 悲观锁
所谓悲观锁是指总是假设对坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到他拿到锁（共享资源每次都只给一个线程使用，其他线程阻塞，用完之后再把资源释放给其他线程）  Java中的synchronized 和reentrantlock 等独占锁就是悲观锁思想的实现

### 乐观锁
乐观锁总是假设最好的情况，每次去拿去数据的时候都认为别人不会修改，所以不会上锁，但是再更新的时候会判断以下在此期间别人有没有去更新这个数据，可用使用版本号机制和CAS 算法来实现， 乐观锁适合用于多读的应用类型，这样可以提高吞吐量。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的

### 两种锁的使用场景
乐观锁适合用于读比较多写比较少的情况下。即冲突很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但是多写场景的下，一般使用悲观锁比较合适

### 乐观锁的实现方式 （CAS 算法）
CAS 即 compare and swap （比较与交换） 一种比较有名的无锁算法，无锁编程，即不使用锁的情况下，实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步， CAS 算法涉及三个操作数
1. 需要读取的内存值 V
2. 进行比较的值A
3. 需要写入的新值B

当且仅当V的值等于A 时，CAS通过原子方式用新值B来更新V的值，否正不会指向任何操作（比较和替换是一个原子操作）一般情况下是一个自旋操作（该操作不会阻塞CPU，如果自旋过久可能会对CPU 造成负担 ，自旋等待的时间必须要有限度。如果自旋超过限定次数仍然没有获得锁，就应该挂起）

### 乐观锁的缺点

1. ABA 问题
> 如果一个变量V初次读取的时候是A ，并且在准备复制的时候检测到他的值仍然是A ，不能说明他的值没有被其他线程修改过，因为在这段时间他的值可能被改为其他值。然后又改回A ，那么CAS 操作就会被误认为他从来没有被修改过，这个问题被称为CAS 操作的ABA  问题
2. 循环（自旋）时间长开销大
> 自旋CAS （也就是不成功就一致循环执行，直到成功） 如果长时间不成功，会给CPU 带来非常大的执行开销，如果JVM 能支持处理器提高的pause指令，那么效率会有一定的提升。 
3. 只能保证一个共享变量的原子操作
> CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效， 但是从JDK1.5 开始 ，提高了 atomic reference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS 操作

### CAS 和synchronized 的使用场景
简单来说， CAS 适合写比较少的场景，synchronized 适合写比较多的场景
1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒需要 需要进行用户态和内核态之间的切换，这样会额外浪费CPU资源，而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能
2. 对于资源竞争严重的情况，CAS 自旋的概率会很大，从而浪费更多的CPU 资源，效率低于synchronized
 
在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS