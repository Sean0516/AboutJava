### 减少锁的持有时间
尽可能减少某个锁的占有时间，以减少线程间互斥的可能如果在一个方法中有多个方法，但是只有一个方法是有同步需要的，可以选择只对需要同步的方法做加锁操作，只在必要的时候进行同步，这样可以明显减少线程持有锁的时间，提高系统的吞吐量。 ==只针对需要同步的方法做同步，锁占用的时间相对较短，能够获得更高的并行度，并且有助于降低锁冲突的可能性，进而提升系统的并发能力==

```
public synchronized void syncMethod(){
method();
syncMethod();
method2();
}
// 改为
public  void syncMethod(){
method();
synchronized（this）{
syncMethod();
}
method2();
}
```
### 减少锁粒度 

减少锁粒度也是一种削弱多线程锁竞争的有效手段，所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力例如并发容器concurrentHashMap就是使用该了该方式 ==JDK1.8并发容器concurrentHashMap 不再使用分段锁==。 对于HashMap来说，最重要的方法就是get和put方法，如果需要多线程方法，一种方法是对整个map进行加锁，但是这样做的话，会存在加锁粒度过大的问题，而concurrentHashMap  则在内部进一步细分了若干个小的hashMap 称之为段（segment） 默认情况下，concurrentHashMap被细分成16段，只要被加入的表项不存放在同一个段中，则线程件便可以做到正在的并行，理论上，concurrentHashMap  可以同时接受16 个线程同时插入，从而大大提高其吞吐量

但是，减少锁粒度会引入一个新的问题，即：==当系统需要获得全局锁的时候，其资源的消耗会比较多。==
 
 ### 使用读写锁来替换独占锁
 使用读写分离锁来替换独占锁是减少锁粒度的一种特殊方式，是对系统功能点的分割的一种实现
 
在读多写少的场合，读写锁对系统性能是很有好处的，因为如果在系统在读写数据时均只使用独占锁，那么读操作和写操作件，读操作和读操作间，写操作和写操作间均不能做到真正的并发，并且需要相互等待，而且读操作本身不会影响数据的完整性和一致性，因此，理论上讲，打大部分情况下，应该可以允许多个线程同时读。

### 锁分离
如果将读写锁的思想进一步的延伸，就是锁分离，读写锁根据读写操作功能上的不同，进行了有效的锁分离，根据应用程序的功能特点，使用类似的分离思想，可以对独占锁进行分离
### 锁粗化
通常情况下，为了保证多线程的有效并发，会要求每个线程持有锁的时间尽量段，即在使用完公共资源后应该立即释放锁，只有这样，等待在这个锁上的其他线程才能尽快地获得资源执行任务，但是，如果对同一个锁不停进行请求，同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。为此，虚拟机在遇到一连串连续对同一锁进行请求和释放的操作，便会将所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化 （锁的粗化，在循环请求锁的时候，需要着重重视）

需要说明的是，性能的优化是需要根据实际情况对资源进行权衡的，锁粗化和减少锁的持有时间是相反的，但是在不同的场合，他们的效果并不相同。


