主要从读写状态的设计，写锁的获取与释放， 读锁的获取与释放以及锁降级来分析读写锁
### 写锁的获取与释放
写锁是一个支持重进入的排他锁， 如果当前线程已经获取了写锁，则增加写状态  如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。如果存在读锁，则写锁不能被获取，原因在于: 读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在允许的其他读线程就无法感知到当前写线程的操作，因此，只有等待其他读线程都释放了读锁，写线程才能被当前线程获取，而读锁一但被获取，则其他读写线程的后续访问均被阻塞

写锁的释放和reentrantLock 的释放过程基本类似，每次释放均减少写状态，当写状态为0 的时候表示写锁已经被释放，从而等待的读写线程能够继续方法读写锁，同时前次写线程的修改对后续读写线程可见

### 读锁的获取和释放
读锁是一个支持重进入的共享锁，他能够被多个线程同时获取， 在没有其他写线程访问时， 读锁总是会被成功的获取，如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态

### 锁降级
锁降级是指写锁降级为读锁，是指把持住当前拥有的写锁，再获取到读锁，随后释放先去拥有的写锁的过程

### 读写状态的设计
读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是同步器的同步状态。读写锁自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键

读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，读写锁通过位运算来获取读和写各自的状态，假设当前同步状态值为S ，那么写状态为S ，而读状态为S >>> 16  (无符号补0 右移16 位) 当写状态增加1 时， 等于S +1  ,当读状态增加1 时，等于 S +（1<<16） 根据状态的划分可以等处一个结论，当S 不等于0 时，当写状态等于 0 时 ，则状态 S>>>  大于0 ，即读锁被获取



