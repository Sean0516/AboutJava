ReentrantReadWriteLock JDK 5 提供的读写分离锁，读写分离锁可以有效的帮助减少锁竞争，以提升系统性能，读写锁允许多个线程同时读，但是考虑到数据的完整性，写写操作和读写操作件依然需要相互等待和持有锁，总的来说，读写锁的约束如下
1. 读-读 不互斥  两者不阻塞
2. 读-写互斥  读阻塞写  ，写也会阻塞读
3. 写- 写 互斥  两者相互阻塞

读写锁在同一时刻允许多个读线程访问，但在写线程访问时，所有的读线程和他的写线程都会被阻塞。 读写锁维护一对锁，一个读锁，一个写锁。通过分离读锁和写锁，使得并发性相比一般的排他锁有很大的提升 。除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。

在没有读写锁之前， 如果需要完成读写等工作，就需要使用Java的等待通知机制，当写操作时，所有多余写操作的读操作都会进入等待状态。只有写操作完成并进行通知后，所有的读操作才能继续执行。 而读写锁在实现上述功能的时候，只需要在读操作的时候获取读锁，写操作的时候获取写锁即可，当写锁获取到时，后续（非当前写操作线程）的读写操作都会被阻塞 ，写锁释放后，所有操作继续执行，

一般情况下， 读写锁的性能比排他锁要好，因为大多数场景读是多于写的，读写锁可以提供比排他锁更好的并发性和吞吐量。 

### 读写锁的特性
1. 公平性选择： 支持非公平（默认）和公平的锁获取方式 ，吞吐量还是非公平由于公平
2. 重进入： 支持重进入。读线程在获取读锁后，能再次获取读锁。写线程获取写锁之后，能再次获取写锁，同时也可以获取读锁
3. 锁降级 遵循获取写锁，获取读锁再释放写锁的顺序，写锁能够降级成为读锁


```
  ReentrantReadWriteLock readWriteLock = newReentrantReadWriteLock();
  Lock readLock = readWriteLock.readLock();
  Lock writeLock = readWriteLock.writeLock();
```
