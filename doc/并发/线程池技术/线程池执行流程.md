### 线程池的处理流程
当提交一个新的线程到线程池时，线程池的处理流程如下：
1. 线程池判断核心线程池是否都在执行任务，如果不是，创建一个新的线程来执行任务，如果核心线程池都在执行任务，则进入下一个流程
2. 线程池判断工作队列是否已经满， 如果工作队列没有满，则将任务存储在工作队列里面，如果工作队列满了，进入下一个流程
3. 线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理一个任务

### JAVA ThreadPoolExecutor 执行execute 方法分下面四种情况
1. 如果当前运行的线程少于corepoolsize  ，则创建新线程来执行任务
2. 如果运行的线程等于或多余 corepool size  则将任务加入 blockingqueue（阻塞队列）
3. 如果无法将任务加入blockingqueue（等待队列已满），则创建新的线程(新的线程数由maxNum pool size 决定)来处理任务
4. 如果创建新的线程将使当前运行的线程超出 maxnum pool size ，任务将被拒绝，并调用 rejected execution handler  （根据里面预先设置的策略进行相应的操作）

ThreadPoolExecutor  采用上诉步骤的总体设计思路，是为了在执行execute 方法时，尽可能地避免获取全局锁。 在	ThreadPoolExecutor  完成预热之后（当前运行线程数大于等于 corePoolSize ） 几乎所有的execute 方法调用都是执行步骤2 ，而步骤2 不需要获取全局锁
