volatile 是轻量级的synchronized  ，他在多处理器并发中保证了共享变量的可见性。 可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 如果volatile变量修饰符使用恰当，他比synchronized的使用和执行成本更低，因为他不会引起线程的上下文切换和调度 

### volatile 定义
Java编程语言允许线程方法共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量.如果一个字段被声明称为volatile,Java线程模型确保所有线程看到这个变量的值是一致的

### volatile 实现原理

如果对声明了volatile的变量进行写操作，JVM 会像处理器发生一条Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里

### lock前缀的指令在多核处理器下会发生两件事情：
1.  Lock前缀的指令会引起当前处理器缓存行的数据写回到系统内存，Lock前缀的指令回导致在执行指令期间，处理器可以独占任何共享内存
2.  这个写回内存的操作会使其他cpu 已缓存了该内存地址的数据无效

处理器使用MESI(修改,独占,共享,无效)的协议去维护内部缓存和其他处理器缓存的一致性，当多核处理器进行操作的时候，处理器能嗅探其他处理器访问系统内存和他们的内部缓存。处理器使用嗅探技术保证他的内部缓存,系统内存和其他处理器的缓存的数据在总线上保持一致。 如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址又处于共享状态，那么正在嗅探的处理器将是它的缓存行无效。下下次访问相同内存地址时，强制执行缓存填充

volatile 关键字可以保证变量会直接从主存中读取，而对变量的更新也会直接写到主存,volatile本质是告诉jvm 当前变量在寄存器中的值是不确定的，需要从主存读取,volatile 仅能在变量级别使用。 volatile不会造成线程的阻塞
