StampedLock 是Java 8 引入的的一种新的锁机制，简单来说，StampedLock是读写锁的一个改进版本，读写锁虽然分离了读写的功能，使得读与读之间可以完全并发，但是，读和写之间依然是有冲突的，读锁会完全阻塞写锁，他使用的依然是悲观的锁策略，如果有大量的读线程，它也有可能引起写线程的饥饿

 StampedLock 提供了一种乐观的读策略，这种乐观的锁非常类似无锁的操作，使得乐观锁完全不会阻塞写线程
 
 StampedLock  在读的时候，首先使用StampedLock .tryOptimisiticRead() 发方法，这个方法表示视图尝试一次乐观锁，它会返回一个类似于时间戳整数 stamp ，这个stamp 就可以作为这一次锁获取的凭证，然后通过 validate 方法，判断这个stamp 是否在读过程发生期间被修改过。如果stamp没有被修改过，则任务这次读取是有效的，可以直接对数据做处理，反之，如果stamp不可用，则意味着在读取的过程中，可能被其他线程改写数据，因此，有可能出现脏读，如果出现这种情况，会一直使用乐观读，直到成功为止。
 
```
       long stmap = stampedLock.tryOptimisticRead();
        if (!stampedLock.validate(stmap)) {
            stmap = stampedLock.readLock();
            readMsg = msg;
            stampedLock.unlockRead(stmap);
        }
```

 
 
 ### StampedLock  的实现思想
 
 StampedLock 的内部是基于CLH锁的，CLH锁是一种自旋锁，它保证没有饥饿发生，并且可以保证 FIFO 的服务顺序
 
CLH 锁的基本思想如下：锁维护一个等待线程队列，所有申请锁，但是没有成功的线程都记录在这个队列中， 每一个节点（代表一个线程），保存一个标记位，用来判断当前线程是否以及释放锁

当一个线程试图获得锁时，取得当前等待队列的尾部节点作为其前序节点，并判断该节点是否已经成功释放锁

只要前序节点没有释放锁，则表示当前线程还不能继续执行，因此会自旋等待。反之，如果前序线程已经释放锁，则当前线程可以继续执行

释放锁时，也遵循这个逻辑，线程会将自身节点的locked位置标记为false，那么后续等待的线程就能继续执行了
