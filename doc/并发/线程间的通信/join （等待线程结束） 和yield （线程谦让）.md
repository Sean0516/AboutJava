### JOIN
主线程创建并启动子线程，如果子线程要进行大量耗时运算，主线程往往将早于子线程结束之前结束，这时，如果主线程想等待子线程执行完成之后再结束， 这是就需要用到join 方法了,方法 join 的作用是等待线程对象销毁方法join的作用是使所属的线程对象X正常执行run 方法中的任务，而使当前 线程Z 进行无限期的阻塞 ，等待线程X 销毁后再继续执行线程Z 后面的代码 JDK 提供了join 操作来实现这个功能。 提供了两个join 方法 (join(), join(long millis))

join()方法表示无限等待，他会一直阻塞当前线程，直到目标线程执行完毕，join(long millis)会给出一个最大等待事件，如果超过给定事件目标线程还在执行，当前线程会跳过等待，继续执行下去

当一个线程执行了join 语句，其含义是： 当前线程等待线程终止后才从thread返回
### 方法 join（long ）和 sleep （long） 的区别

join 的功能在内部使用的wait方法来实现，所以join方法具有释放锁的特点，所以，当执行了 join方法，当前线程的锁被释放，其他线程就可以调用该线程中的同步方法，而==sleep方法不释放锁==
### join方法的使用
join方法用线程对象调用，如果在一个线程A中调用另一个线程B的join方法，线程A将会等待线程B执行完毕后再执行。所谓合并，就是等待其它线程执行完，再执行当前线程，执行起来的效果就好像把其它线程合并到当前线程执行一样。

```
//从主线程调用thread 的join 方法，主线程需要等待thread 结束，才会继续主线程后续的任务 
    Thread thread=new Thread(joinThread);
    thread.start();
    thread.join();
```


### yield() 
yield() 方法是一个启发式的方法，会提醒调度器自身线程愿意放弃当前CPU资源。一旦执行，他会使当前线程让出CPU，但是要注意的是，让出CPU并不表示当前线程不执行了，当前线程在让出CPU 之后，还会进行CPU资源的争夺，但是能否再次分配到资源就不一定了，因此，yield()的调用就好比是，停止自己的线程工作，将资源让给其他的线程。

yield可以直接用Thread类调用，yield让出CPU执行权给同等级的线程，如果没有相同级别的线程在等待CPU的执行权，则该线程继续执行。yield()方法让当前正在执行的线程暂停,但不是阻塞线程,而是让该线程转入就绪状态,重新等待调度。 需要注意的是，yield 只是一个提示 ，CPU调度器并不会保证每次都满足yield 提示。注意: yield()方法可移植性并不是很好, 而且很有可能导致死锁.所以并不推荐使用

```
Thread.yield();
```









