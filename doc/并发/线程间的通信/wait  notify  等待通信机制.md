等待通知机制是指一个线程A调用了对象O的wait()方法进入等待状态，而另外一个线程B 调用了对象O 的notify  或者notifyAll方法，线程A收到通知后从对象O的wait方法种返回，进而执行后续操作。

### notify notifyAll 
通知一个在对象上等待的线程，使其从wait方法返回，而返回的前提是该线程获取到了对象的锁 notifyAll  通知所有等待该对象的线程
### wait   wait (long) wait(long ,int) 
1. 调用wait()方法，线程进入waiting状态，只有等待另外线程的通知或者被中断才返回 。需要注意，调用了wait方法后，会释放对象的锁.
2. wait(long)超时等待一段时间，如果没有通知就超时返回 
3. wait(long ,int) 对于超时时间更细粒度的控制，可以达到纳秒

### 等待通知机制需要遵循的原则
#### wait 需要遵循的原则
1. 获取对象锁
2. 如果条件不满足，调用对象的wait方法，被通知后仍要检查条件（是否获得锁）
3. 条件满足则执行对于的逻辑
####  notify遵循原则
1. 获取对象锁
2. 改变条件
3. 通知所有等待在对象上的线程

通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁，而notify操作可以唤醒因调用了wait操作而处于waiting状态，使其进入就绪状态，被重新唤醒的线程会试图重新获取临界区的控制权（锁），并继续执行临界区内wait之后的代码。进入等待队列，直到被再次唤醒

每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个线程被唤醒后，才会进入就绪队列，这些这些线程就可以去竞争锁了。 当一个线程被wait 后，就会进入阻塞队列，等待下一次被唤醒。

wait() 方法调用后，锁会自动释放，而notify方法调用后，锁是不自动释放的，需要把同步代码块执行完之后才释放锁线程之间的通信机制 除了wait 和notify   还有reentrantLock  可以实现 线程直线的通信  ，使用lock 和unlock 来实现

### wait notify机制的一些细节
1. 使用wait notify 是需要先对调用对象加锁
2. 调用wait 方法后，线程状态有running变为waiting ，并将当前线程放置到对象的等待队列
3. notify notifyall 方法调用后，等待线程依旧不会从wait 返回，需要调用notify 的线程释放锁之后，等待线程才有机会从wait返回
4. notify 方法将等待队列种的一个等待线程从等待队列移到同步队列中，而notifyAll  将等待队列中所有的线程全部移到同步队列，被移动的线程状态由waiting变为blocked
5. 从wait 方法返回的前提是获得了调用对象的锁
6. 当线程处于处于wait 状态，调用线程对象的Interrupt 方法会出现中断异常