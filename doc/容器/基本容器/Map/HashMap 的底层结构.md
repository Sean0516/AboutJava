### 存储结构

#### 1.8 之前
JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经
过扰动函数处理过后得到 hash 值，然后通过  (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的
长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的
话，直接覆盖，不相同就通过拉链法解决冲突。

所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的
hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞

```
//JDK1.8 
static final int hash(Object key) {
int h;
// key.hashCode()：返回散列值也就是hashcode
// ^ ：按位异或
// >>>:无符号右移，忽略符号位，空位都以0补齐
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

```

所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，==数组中每一格就是一个链表。若遇到哈希
冲突，则将冲突的值加到链表中即可。==

#### 1.8 之后

相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转
化为红黑树 (主要是为了解决一旦出现拉链过长，HashMap的性能问题)，以减少搜索时间。 （利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。）

TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺
陷，因为二叉查找树在某些情况下会退化成一个线性结构。

![image](https://pic1.zhimg.com/80/8db4a3bdfb238da1a1c4431d2b6e075c_720w.png) 

### 字段
HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。
Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象

HashMap 使用哈希表来存储。为解决哈希表冲突， 使用链地址法来解决。 简单来说，就是数组加链表的结合，在每个数组元素上都有一个链表结构，当数据被Hash 后，得到数组下标。把数组放在对应下标元素的链表上。 有的时候，当两个key 定位到相同的位置时，表示发生了hash 碰撞。 