在很多应用场景中，读操作可能会远远大于写操作。 由于读操作根本不会修改原有数据，因此对于每次读取都进行加锁其实是一种资源浪费。和读写锁ReentrantReadWriteLocak 思想类似。也就是读读共享，写写互斥，读写互斥，写读互斥。 而CopyOnWriteArrayList 相比读写锁在思想上更进一步。 为了将读取的性能发挥到机制， CopyOnWriteArrayList 读取完全不用加锁，并且更厉害的是，写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。

### 实现原理

CopyOnWriteArrayList 类的所有可变操作（add ,set 等）都是==通过创建底层数组的新副本来实现==。当list 需要被修改的时候，并不修改原来的内容，而是对原有的数据进行一次复制，将修改的内容吸入副本，写入之后，将修改后的副本替换原来的数据，这样就可以保证写操作不会影响读操作了 。 也就是说，在计算机中，如果你想对一块内存进行修改时，我们不再原有内存块中进行写操作，而是将内存拷贝一份。在新的内存中进行写操作。写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了


CopyOnWriteArrayList 读取操作没有任何的同步控制和锁，因为内部数组array 不会发生修改， 只会被另外一个array 替换，因此可以保证一个数据安全

CopyOnWriteArrayList 在写入操作的时候add 方法在添加集合的时加了锁，保证了同步， 避免了多线程写时会copy出多个副本来