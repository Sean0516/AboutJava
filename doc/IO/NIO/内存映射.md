内存映射主要为了提高大文件的读写速度而设计。内存映射文件能让你创建和修改那些大到无法读入内存的文件，有了内存映射文件，你就可以认为文件已经全部读取进了内存，然后把他当成一个非常大的数组来访问。 将文件的一段区域映射到内存中，以传统的文件处理速度要快很多，内存映射文件他虽然最终是要从磁盘读取数据，但是他并不需要将数据读取到OS 内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系吗，就好像直接从内存中读写文件一样。 

NIO中内存映射主要用到以下两个类：

1. java.nio.MappedByteBuffer
2. java.nio.channels.FileChannel


```
        File file = new File("demo");
        long len = file.length();
        byte[] ds = new byte[(int) len];
        MappedByteBuffer byteBuffer = new FileInputStream(file).getChannel().map(FileChannel.MapMode.READ_ONLY, 0, len);
        for (int i = 0; i < len; i++) {
            ds[i] = byteBuffer.get();
        }
```


### 映射模式
1. FileChannel.MapMode.READ_ONLY  ：只读缓冲区，在缓冲区中如果发生写操作则会产生 ReadOnlyBufferException
2. FileChannel.MapMode.READ_WRITE: 读写缓冲区，任何时刻如果通过内存映射的方式修改文件则会立刻对磁盘上的文件执行相应的修改操作。别的进程如果也共享了同一个映射，则也会同步看到变化，而不是像标准IO 那样每个进程都有各自的内核缓冲区。 例如在BIO 中，如果不执行 IO输出流的 flush 或 close 操作，那么文件的修改就不会更新到磁盘里，除非进程运行结束
3. FileChannel.MapMode.PRIVATE 可协缓冲区，但任何修改都是缓冲区私有的，不会回到文件中。

### 性能分析
从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。
但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？

read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；
map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。

### 内存映射的优缺点

1. 用户进程将文件视为内存，不需要发出read 或write 系统调用
2. 当用户进程触摸映射的内存空间时，将自动生成页面错误，以从磁盘引入文件数据 。如果用户修改映射的内存空间，受影响的页面将自动标记为脏， 并随后刷新到磁盘以更新文件
3. 操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存
4. 可以映射非常大的文件，而不需要大量内存来复制数据
5. MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。
6. 如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。
7. MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。
