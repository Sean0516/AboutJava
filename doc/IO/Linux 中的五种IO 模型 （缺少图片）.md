在Java中的BIO NIO 和 AIO 都是 Java语言对操作系统的各种IO模型的封装，程序员在使用这些API的时候，不需要关系操作系统层面的知识，而也不需要根据不同操作系统编写不同的代码，只需要使用JAVA 的API 就可以了在Linux 操作系统中，一共有五种IO 模型， 分别是阻塞IO 模型（BIO）， 非阻塞IO 模型 ，IO服用模型， 信号驱动模型 以及异步IO 模型 （AIO）==所谓IO 就是将文件从磁盘拷贝到用户空间的过程==

1. 阻塞IO 

阻塞IO 是最简单的IO 模型，一般表现为进程或线程等待某个调整，如果条件不满足，则一直等待下去，条件满足，则进行下一步操作。

具体流程如下

 应用进程通过系统调用 recvfrom 接收数据------ 当内核未准备好数据报，则应用进程阻塞，等内核准备好数据报，recfrom 完成数据报复制工作（将数据从内核复制到用户空间） 等数据报复制完成后，应用程序结束阻塞状态。 （需要注意的是，复制数据报时，应用进程也是阻塞的）

2.  非阻塞IO 模型

非阻塞IO ，是指应用进程和内核交互，在母的未达到之前，不再一味的等待，而是直接返回，然后通过轮询的方式，不停地去询问内核数据是准备好，如果某次轮询发现数据已经准备好，则把数据从内核拷贝到用户空间。

具体流程如下

应用程序通过recvfrom 不停地和内核交互，如果内核没有准备好数据，内核会返回error ，应用进程在等到erro 后，会在 过一段时间再发送recvfrom 请求，知道数据准备好，数据准备之后，则将数据从内核复制到用户空间，最后应用程序对数据进行处理

3.   信号驱动IO 模型

应用进程在获取获取文件时使用 sigaction 系统调用 用于在内核注册一个处理函数，然后应用进程返回返回，并且不阻塞。  当内核准备好数据报后， 向应用进程发送一个信号，应用进程在获取到信号后， 应用进程通过 recvfrom 完成数据复制，并处理数据报。
4.   IO 复用模型

IO 复用模型是指多个进程的IO 可以注册到同一个管道上，这个管道会统一和内核进行交互，当管道中的某个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间


5.   异步IO 模型

应用进程把IO 请求传给内核后，完全由内核完成数据的准备和拷贝，内核完成相关操作后，发信号通知应用进程本次IO 已经结束。 具体流程为：

用户进程发起 aio_read 操作后，给内核传递描述符，缓冲区指针，缓冲区大小等，告诉内核当整个操作完成时，如果通知进程，然后就立刻取做其他事情，当内核收到 aio_read  后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成


阻塞式IO | 非阻塞式IO  | IO 复用 | 信号驱动式 IO | 异步IO
---|---|---|---|---
发起                                |检查（轮询访问内核是否准备好数据） | 检查                  |                            | 发起
阻塞（内核准备数据报）              |检查                               | 阻塞 （内核准备数据报 |                            | 异步
阻塞                                |就绪                               | 就绪                  | 通知发起（数据准备好后）   | 异步
阻塞 （recvfrom 复制数据到用户空间）|阻塞（数据复制）                   | 阻塞 （数据复制）     | 阻塞（数据复制）           | 异步
完成                                |完成                               | 完成                  | 完成                       | 通知










