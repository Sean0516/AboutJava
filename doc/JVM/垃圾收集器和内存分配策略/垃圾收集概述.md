### 关于GC 需要考虑三件事情
1. 那些内存需要回收
2. 什么时候回收
3. 如何回收

由于Java虚拟机内存运行时区域有多个部分，而其中程序计数器，虚拟机栈，本地方法栈这些区域随着线程而生，随着线程而灭。 栈中的栈帧随着方法的进入和退出而有条不紊地指向这出栈和入栈操作。每一个栈帧中分配多少内存基本在类结构确定下来时就已知。因此这些区域的内存回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样。一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间时才能知道会创建那些对象，这部分内存的分配和回收都是动态的。 垃圾回收器关注的就是这部分内存

通常我们把GC 管理的内存称为堆，垃圾收集启动的时机取决于各个垃圾收集器，通常来及收集发生于整个堆或堆部分已经使用光了，或者使用的空间达到了某个百分比阈值。 对于内存分配请求，实现的难点在于在堆中找到一块没有使用的确认大小的内存空间，所以，对于大部分垃圾回收算法来说，避免内存碎片化非常重要，他将使得空间分配更加高效
### 垃圾收集器的理想特性

1. 安全和全面 ： 活的对象一定不能被清理掉，死的对象一定不能在几个回收周期结束后还在内存中
2. 高效：不能将我们的应用程序挂起太长时间，需要在时间，空间，频次上做出权衡
3. 尽量少的内存碎片 ： 每次将垃圾对象释放以后，这些空间可能分布到各个地方。最糟糕的是，内存中到处都是碎片，再给一个大对象分配内存时没有足够的内存，但是实际上内存是够的。 消除碎片的方式就是压缩
4. 可扩展性 

