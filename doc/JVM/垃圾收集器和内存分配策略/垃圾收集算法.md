垃圾收集算法主要有 标记-清理，复制，标记-整理，分代收集算法。以下是这几种算法的具体机制
### 标记-清除算法
最基础的垃圾收集算法是标记-清除算法  ，算法分为 标记 和 清除 两个阶段 。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象  之所以说他是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。 他的主要不足有两个 ： 一个是效率问题，标记和清除两个过程的效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在这个程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作。
### 复制算法
复制算法将可用内存按照容量划分为大小相等的两块。每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配的时候也就不需要考虑内存碎片等复杂情况。只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，但是这种算法的代价在于将内存缩小为原来的一般，代价太高

现在的商业虚拟机都采用复制算法这种收集算法来回收新生代，研究表明，新生代中的对象 98% 是 朝生夕死的 ，所以并不需要按照1:1 的比例来划分内存空间，而是将内存分为一块较大的Eden 空间和两块较小的Survivor空间 ，每次使用Eden 和其中一块Survivor 空间上。 当回收时，将Eden 和Survivor 中还存活的对象象征性地复制到另外一块Survivor 空间上，最后清理掉Eden 和刚才用用过的Survivor空间。如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代

### 标记--整理算法
根据老年代的特点，提出了 标记--整理算法，标记过程仍然和标记--清理 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。该算法可以解决 标记-清理算法造成的内存碎片的问题

### 分代收集算法
当代商业虚拟机的来及收集器都是采用 分代收集算法，这种算法主要是根据对象存活周期将内存划分为几块。 一般是将Java堆分为新生代和老年代。 然后根据各个年代的特点采用最适当的收集算法 ，由于在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，那么就采用复制算法，只需要付出少量存活对象的复制成本就可用完成收集。而由于老年代的对象存活率较高，没有额外空间对他进行分配担保，就必须使用标记--整理 或标记--清理（一般是使用整理算法）来进行回收 
