Java技术体系中所提倡的内存自动管理最终可以归结为自动化解决两个问题 ： 给对象分配内存以及回收分配给对象的内存。对象的内存分配，大的方向就算是在堆上分配， 对象主要分配在新生代的Eden 区 上，如果启动了本地线程分配缓存，将按线程优先在TLAB 上分配。 少数情况下也可能会直接分配在老年代中。以下是几条最普遍的内存分配规则

### 对象优先在Eden 区分配
目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样可以根据不同年代选取不同的垃圾回收算法， 一般来说， 新生代采用复制算法， 老年代采用标记-整理算法。 当然，对于不同的来及收集器，算法也不同

大多数情况下，对象在新生代的Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次 minor GC ，当进行 minor GC ，GC 期间发现 Surviovr 空间不够时，将会通过分配担保机制，将新生代的对象提前转移到老年代中去。 这样就是下面所说的 大对象直接进入老年代。

##### （Mnior GC 和 Full GC 的区别）
1. 新生代 GC （Mnior GC）指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性。所以Mnior GC非常频繁，一般回收速度也比较快
2.  老年代 GC（Magor GC / Full GC） 当老年代被填满了，会触发Full GC ,full GC 会收集所有的区域，先进行年轻代的收集，使用年轻代垃圾收集算法，然后使用老年代的垃圾回收算法回收老年代和永久代， 如果先进行年轻代垃圾收集，会使得老年代不能容纳要晋升上拉的对象，这种情况下， 不会先进行 minor GC ，所有的收集器会直接采用老年代的收集算法堆整个堆进行收集  Full GC 的速度一般会比Minor  GC 慢10倍以上

### 大对象直接进入老年代
所谓大对象是指需要大量连续内存空间的JAVA对象，典型的大对象就是那种很长的字符串以及数组。 大对象对于虚拟机的内存分配来说是个很坏的消息，经常出现大对象容易导致内存中还有不少空间的时候就需要提前触发垃圾回收来获取更多的连续空间

虚拟机提供了一个 -XX：PretenureSizeThreshold参数，大于这个设置值的对象直接在老年代中进行内存分配， 这样做的目的在于避免新生代发生大量的内存复制

### 长期存活的对象进入老年代
虚拟机给每一个对象定义了一个对象年龄计数器。如果对象在Eden区出生，经过第一次新生代GC 仍然存在，并且能够被Survivor容纳的，那么将会移动到Survivor空间，并且对象年龄设置为1  ，对于Survivor区中的对象，只要每进过一次新生代GC，对象年龄就增长一岁，当对象年龄到达晋升老年代的阈值（默认为15，对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置 ） 那么对象就会被晋升到老年代。


### 动态对象的年龄判定
为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果survivor 空间中相同年龄所有对象大小的总和大于survivor 空间的一般，年龄大于或等于该年龄的对象就直接进入老年代，无需达到要求的年龄

### 空间分配担保
在发生新生代GC 的时候，虚拟机会区检查老年代的连续空间大小是否大于新生代所有对象总空间，如果成立，那么就可以确定新生代GC行为是安全的，但是如果小于，那么就需要查看是否允许担保失败，如果允许，继续检查新生代需要晋升的对象的大小是否小于老年代的可用连续空见，如果大于，尝试进行新生代GC，如果小于或者不允许进行担保失败，那么新生代GC 就会变成老年代 GC

### 总结
存回收和来及收集器很多时候都是影响系统性能，并发能力的主要因素之一，只有根据实际应用需求，实现方式选择最优的搜集方式才能获取最高的性能。在实际的虚拟机调优阶段，必须了解具体收集器的行为，优势和劣势，以及调节参数，根据程序的实际情况进行调优