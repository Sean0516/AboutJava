java 定义了若干种程序运行期间会使用到的运行时数据区，其中有的会随着虚拟机启动而创建，随着虚拟机退出而销毁，另外一些则是线程一一对应，这些与线程对应的数据库区域会随着线程开始而创建，线程结束而销毁。

Java虚拟机在执行Java程序的过程中会把他管理的内存分为以下几个不同的区域。这些组成部分一部分是线程私有的（虚拟机栈（栈帧），本地方法栈， 程序计数器） 一部分是线程共享的（堆 ，方法区 （运行常量池））
以下是Java运行时的数据区

### 程序计数器（PC 寄存器）
Java 虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的pc（program counter 程序计数器）寄存器。在任何时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法被称为当前方法，如果这个方法不上native的，那么pc寄存器就保存Java询级正在执行的字节码指令地址，如果该方法是native的，那么pc 寄存器的值就是undefined的，pc 寄存器的容量至少应当能保存一个returnaddress类型的数据或一个与平台相关的本地指针的值

对于一个运行的程序而言，其中的每一个线程都有自己的PC寄存器，他是在该线程启动时创建，PC 寄存器的大小是一个字长，因此他技能持有一个本地指针，又能持有一个returnaddress。当线程执行某个方法时，PC寄存器的内容总是下一条将被执行指令的地址

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器工作时需要通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖程序计数器来完成

程序计数器有以下两个作用：
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制

2. 在多线程的情况下，程序计数器用于当前线程执行的位置，从而当线程切换回来的时候能够知道该线程上次运行到那里了
 
### Java 虚拟机栈
和程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期和线程相同，描述的是Java方法执行的内存模型 。实际上。Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表，操作数栈，动态链接 ，方法信息

每当启动一个新的线程时，Java虚拟机都会为他分配一个私有的java虚拟机栈，这个栈与线程同时创建，用于存储栈帧 。Java栈以帧为单位保存线程的运行状态，虚拟机只会对Java栈执行两种操作， 以帧为单位的 压栈或出栈。 当线程运行一个Java方法时，虚拟机在Java栈中压入一个新帧，并且，在执行这个方法时，使用这个帧来存储参数，局部变量，中间运算结果等数据 。

Java虚拟机规范既允许Java虚拟机被栈被实现成固定大小，也允许根据计算动态来扩展和收缩

### 本地方法栈
 java虚拟机实现可能会使用到传统的栈，来支持native方法的执行，这个栈就称为本地方法栈（native method stack） 当Java虚拟机使用其他语言（例如C）来实现指令集解释器时，也可以使用本地发方法栈。如果虚拟机支持本地方法栈，那么这个栈一般会在线程创建的时候按照线程分配
 
本地方法栈和虚拟机栈类似，区别在于，虚拟机栈为虚拟机指向Java方法服务，而本地方法栈为虚拟机使用到的native方法服务
### 堆
堆是Java虚拟机管理内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。堆内存区域的唯一目的就是存放对象实例，堆是可供各条线程共享运行时的内存区域，也是供所有类实例和数组对象分配内存的区域，几乎所有的对象实例都在这里分配

java堆在虚拟机 启动的时候创建，他存储了被自动内存管理系统（也就是常说的GC 垃圾回收器） 所管理的各种对象，这些受管理的对象无序，也无法显式的销毁。

Java堆是垃圾收集器管理的主要区域，因此也被称为 GC 堆。 从垃圾回收的角度来看，由于现在收集器基本都是采用分代垃圾收集算法，所以Java堆可以分为新生代（Eden ,S1 S2 ） 老年代。  需要注意的是,JDK 8 移除了永久代，取而代之的是元空间的区域（永久代使用的是JVM 的堆内存空间，而元空间使用的是物理内存，直接受本机物理内存限制）

Java 堆的容量可以是固定的也可以是动态扩展的，并在不需要过多空间的时候自动收缩，Java堆所使用的内存不需要保证是连续的

### 方法区
方法区也线程共享的内存区域，他用于存储已被虚拟机加载的每一个类的结构信息，例如运行时常量池，字段和方法数据，构造函数，和普通方法的字节码内容，还包括一些在类，实例，接口初始化时使用到的特殊方法  。方法区在虚拟机启动的时候被创建。  虽然Java虚拟机规范将方法区描述为堆的逻辑部分，但是他却有一个别名叫做 非堆 ，目的是为了于Java堆区分开来
##### 虚拟机会在方法区中存储以下类信息
1. 这个类的全限定名
2. 这个类的直接超类的全限定名
3. 这个类是类类型还是接口类型
4. 这个类的访问修饰符
5. 任何直接超接口的全限定名的有序列表

##### 被装载的类存储以下信息
1. 该类型的常量池 （该类型所用常量的一个有序集合，包括直接常量和对其他类型，字段和方法的符号引用）
2. 字段信息 （对类中声明的每一个字段 包括 字段的名 ，类型，修饰符）
3. 方法信息 （方法名。方法的返回类型， 方法参数的数量和类型 ，犯法的修饰符   ）
4. 除了常量以外的所有类（静态）变量  （由所有的类实例共享，但是即使没有任何类实例，他也是可以被访问的。）
5. 一个到类的classloader 引用
6. 一个到class 类的引用 （对于每一个被装载的类型，虚拟机都会相应地为他创建一个Java。lang.class 类的实例，而且虚拟机还必须以某种方式把这个实例和存储在方法区中的数据关联起来）

### 运行时常量池 
运行常量池是每个类或者接口的常量池的运行时表示形式，他包含； 若干种不同的常量，从编译器克制的数值字面量到必须在运行期解析后才能获得的方法或字段引用。

每一个运行时常量池都分配在 Java 虚拟机的方法区之中。在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来

### 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是着部分内存也被频繁的使用，而且也可能导致outofmemoryerror  异常出现

在jdk 1.4  中新加入了NIO 类，引入了一种基于通道于缓冲区的I/O 方式，他可以使用native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提供性能，因此避免了 在Java 堆和native堆中来回复制数据

虽然本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到总内存（包括RAM 以及SWAP 区或者分页文件）大小以及处理器寻址空间的限制，服务器管理员在配置虚拟机参数时，会根据实际内存设置堆内存大小，但是经常忽略直接内存的大小。使得各个内存区域总是大于物理内存限制，从而导致动态扩展时出现outMemoryError异常

