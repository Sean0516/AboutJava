### 对象的创建
Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象的创建，在语言层面上， 创建对象（例如克隆，反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（只讨论普通Java对象，不包括数组和class 对象等）的创建的过程如下

1. 当遇到new  指令后,首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并检查这个符号引用是否被加载，解析，初始化，如果没有，就需要先进行类加载
2. 当类加载通过后，虚拟机将为新生对象分配内存，对象所需内存的大小类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。虚拟机堆内存有两种分配方式，如果堆内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另外一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式称为 指针碰撞 。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上那些内存块是可用的列表，记录上那些内存是可用的，再分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配称为 空闲列表 。选择那种分配方式由Java堆是否规整规定，而Java堆是否规则又由所采用的垃圾回收器是否带有压缩整理功能决定
3. 内存分配完毕后，虚拟机需要将分配到的内存空间初始化为零值，如果使用TLAB ，则这一工做过程也可以提前至TLAB 分配时进行。 这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值
4. 虚拟机对对象进行对象头进行设置,例如这个对象是那个类的实例，如果才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些对象存放在对象的对象头里面
5. 进行init 初始化 ，把对象按照程序员的意愿进行初始化，这样一个真正可以使用的对象才算安全生产出来

由于对象创建在虚拟机中是非常频繁的行为，所以需要考虑在并发情况下的线程安全问题。 有两种方式解决以下问题 

1. 对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上失败重试的方式保证更新操作原子性
2.把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB） 那个线程需要分配内存，就在那个线程的TLAB 上分配，只有TLAB 用完并分配新的TLAB 时，才需要同步锁定

### 对象中的内存分配
对象在内存中存储的布局分为 对象头，实例数据，和对齐填充
##### 对象头
对象头包括两部分信息：第一部分 对象自身运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程ID ，偏向时间戳等。
第二部分是类型指针，即对象只想他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例
##### 实例数据
对象真正存储的有效信息，也是程序代码定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来，这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响
##### 对齐填充
不是必然存在的，也没有特别的含义，他仅仅起着占位符的作用。 由于hotspotVM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，对象的大小必须是8 字节的整数倍，而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐来填充不全

### 对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆杀那个的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用因该通过何种方式去定位，访问堆中的对象的具体位置。所以对象访问方式也就取决于虚拟机实现而定的。目前主流的方式有使用句柄和直接指针两种

##### 句柄访问
如果使用句柄访问，Java堆将会划分出一块内存referenc来作为句柄池，reference这家拍卖行此存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息
##### 指针访问
如果直接使用指针访问，那么Java堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，而referenc 中存储的直接就是对象的地址

句柄的好处在于：在对象被移动时只会改变句柄中的实例数据指针 ，reference 本身不需要修改
直接指针的好处在于速度够快，他节省了一次指针定位的时间开销，但是由于对象的访问在Java中非常频繁，当开销过多就会形成很大的执行成本