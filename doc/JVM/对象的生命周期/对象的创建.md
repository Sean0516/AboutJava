### 对象的创建过程
对象的创建过程答题如下：

类加载检查-->  分配内存--> 初始化零值--> 设置对象头-->执行init方法

##### 1. 类加载检查
虚拟机遇到一条new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载过，解析和初始化过。 如果没有，那么必须先执行相应的类加载过程
##### 2. 分配内存
在加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需的内存大小在类加载完成后就可以确定， 为对象分配空间的任务等同于把一块确定的大小从Java堆中划分出来。 分配方式有“指针碰撞” 和“空闲列表”两种。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规则又由所采用的垃圾收集器是否带有压缩整理功能决定的。 以下是内存分配的两种方式
1. 指针碰撞  主要适用于堆内存规整的的情况，使用原理是将用过的内存全部整合到一边，没有用过的内存放到另外一边，中间有一个分界值指针，只需要向着没用的的内存方向将该指针移动对象大小位置即可
2. 使用于堆内存不规整的情况下/ 原理是虚拟机维护一个列表，该列表会记录那些内存块是可用的。在分配内存时，找一块足够大的内存块来划分给对象示例，最后更新列表记录

##### 内存分配并发的问题

在创建对象的时候有一个很重要的问题，就是线程安全。作为虚拟机来说，必须保证线程是安全的，通常来说，虚拟机采用两种方式来保证线程安全
1. CAS +失败重试 ，CAS 是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试， 直到成功为止。 虚拟机采用CAS 配上失败重试的方式保证更新操作的原子性
2. TLAB 为每个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB 分配，当对象大于TLAB 的剩余内存或TLAB 的内存已用尽时，再采用上诉的CAS 进行内存分配

### 3. 初始化零值
内存分配完毕后，虚拟机需要将分配到内存空间都初始化为零值（不包括对象头）这一步操作保证了对象再实例字段再Java代码中可以不赋初值就直接使用，程序能方法到这些字段的数据类型所对象的零值
### 4. 设置对象头
初始化零值完成之后，虚拟机要对对象进行必要的设置， 例如这个对象是那个类的实例，如果才能找到类的元数据信息，对象的哈希码 对象的GC 分代年龄等，这些信息存放再对象头中
### 5. 执行init方法
在上面工作都完成之后，从虚拟机的角度来看，一个新的对象就已经产生了，但是从java 程序的来看，对象创建才刚开始， init方法俺没有执行，所有的字段都还为0， 所以一般来说，执行new指令之后会接着执行init方法，把对象按照程序员的意愿进行初始化， 这样一个真正可用的对象才算完全产生出来

